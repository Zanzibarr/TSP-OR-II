The exact algorithms for the TSP algorithm described in this section are all based on \textit{CPLEX}, which uses a proprietary implementation of the \textit{branch \& bound (B\&B)} method to return a solution to the input model. Most of the times, we can expect an "optimal" solution with an integrality gap close to zero. However, since it is computationally infeasible to add every possible SEC to the model, CPLEX will return a solution which is feasible for its internal model but infeasible for our original TSP problem. Thus, we use various techniques to find a good solution for the TSP problem using CPLEX.

\section{Benders' loop}
A simple approach to use SECs without computing all of them is the \textit{Benders' loop} technique. We start with a model with no SECs. Given the solution returned by CPLEX, we identify its various connected components and compute the SECs on those components alone. We repeat the procedure with the new model until we get a solution with only one connected component or we exceed the timelimit.

This method is guaranteed to reach a feasible solution for the TSP problem if the timelimit is not exceeded, but this will happen only at the final iteration: if the time runs out before we find such feasible solution, we will have an infeasible one with multiple connected components. Moreover, it does not always improve the lower bound for the final solution, since the number of connected components of the solutions found throughout the algorithm's execution is not always decreasing.
\newpage
\FloatBarrier
\subsection{Pseudocode}
\begin{algorithm}[h]
    \caption{Benders' loop}

    \textbf{Input} none\\
    \textbf{Output} Hamiltonian cycle of V, cost of cycle\\
    \begin{algorithmic}

        \State *build CPLEX model from $G$ with objective function and degree constraints*\\
        \While{*time limit not exceeded*}
            \State $x^* \gets$ *solution of CPLEX model*
            \State *determine connected components of $x^*$*\\

            \If{*number of connected components == 1*}
                \State cycle, cost $\gets$ *output values computed from $x^*$*\\
                $\quad\;\;\quad\;\;$\Return cycle, cost
            \EndIf\\

            \ForEach{*connected component $S\subset V$ in $x^*$*}
                \State *add SEC to model: $\sum_{e\in\delta(S)}x_e\leq|S|-1$*
            \EndFor
        \EndWhile

    \end{algorithmic}
\end{algorithm}
\FloatBarrier

\section{Patching heuristic}
The major flaw of this method is returning a feasible solution only at the very last iteration. A possible solution to this issue is the implementation of a \textit{patching} heuristic. Given the CPLEX solution at any iteration, we patch together the various connected components to provide a feasible solution even if the timelimit is exceeded before getting a solution with a single component.

Two components $k1\neq k2\subset V$ are patched by replacing two edges $(p_i, p_{i+1})\in k1$ and $(p_j, p_{j+1})\in k2$ with the pair of edges of minimal cost between $(p_i,p_j), (p_{i+1},p_{j+1})$ and $(p_i,p_{j+1}),(p_j, p_{i+1})$. We iterate through all combinations of $k1,k2$ to find the swap with the lowest increase in cost. Once we find the swap, we perform it and repeat the process until we are left with only one connected component.

This procedure may introduce some crossing edges into $x^*$. Thus, we apply the 2opt algorithm after this procedure to remove them.

\newpage
\subsection{Pseudocode}
\begin{algorithm}[h]
    \caption{Patching heuristic Benders' loop}
    \textbf{Input} solution $x^*$ returned by CPLEX with ncomp connected components\\
    \textbf{Output} $x^*$ with 1 connected component\\
    \begin{algorithmic}

        \While{ncomp$\neq1$}
        \State $best\_k1\gets0, best\_k2\gets0, best\_delta\gets-\infty$;
        \For{$k1\gets0$ to $ncomp-1$, $k2\gets k1+1$ to $ncomp-1$}
        \ForEach{$(p_i,p_{i+1})\in x^*$ with $p_i,p_{i+1}\in k1$, $(p_j,p_{j+1})\in x^*$ with $p_j,p_{j+1}\in k2$}
        \State $delta\_N\gets$ change in cost of solution produced by replacing
        \State $(p_i,p_{i+1}), (p_j,p_{j+1})$ with $(p_i,p_{j+1}), (p_j,p_{i+1})$ in $x^*$;
        \State $delta\_R\gets$ change in cost of solution produced by replacing
        \State $(p_i,p_{i+1}), (p_j,p_{j+1})$ with $(p_i,p_j), (p_{j+1},p_{i+1})$ in $x^*$;
        \State $delta\gets\max\{delta\_N,delta\_R\};$
        \If{$delta>best\_delta$}
        \State $best\_delta \gets delta$;
        \State $best\_k1\gets k1$
        \State $best\_k2\gets k2$
        \EndIf
        \EndFor
        \EndFor

        \State patch components $best\_k1,best\_k2$ applying transformation with change in cost
        \State $delta$;
        \State decrease cost of $x^*$ by $best\_delta$;
        \State $ncomp \gets ncomp-1$;
        \EndWhile
    \end{algorithmic}
    
\end{algorithm}

\subsection{Results analysis}

We compared the results obtained by Benders' loop both with and without the patching heuristic. Within this timeframe the algorithms produced solutions with the same costs but took different amounts of time.

\FloatBarrier
\begin{figure}[h]
    \centering
    \includegraphics*[width=.6\textwidth]{../plots/perfprof_benders_times.png}
    \caption*{20 instances, 300 nodes, time limit: 360s}
\end{figure}
\FloatBarrier

The patching heuristic allowed the algorithm to reach a feasible solution in less time. This is in line with the nature of Benders' loop: the base version of the algorithm produces a feasible solution only at the very last iteration, an issue that can be avoided by patching the components after every iteration.

\section{Inside CPLEX using callbacks}

CPLEX lets us create functions to be used as callbacks: in some point of CPLEX execution, it calls these functions (if they have been set), so that we can execute our code inside CPLEX to help him with our knowledge about the problem.\\
We will help CPLEX mainly by addding SEC to the model and posting some heuristic solutions to help him improve the upper bound.\\
Posting heuristic solutions helps CPLEX by shrinking the gap between the incumbent and upper bound, making the Branch and Cut inside CPLEX faster.

\subsection{Candidate callback}
The candidate callback is called each time an integer solution is found: the solution might contain more than one connected component, since we never specified SEC in the model, so we have to find those connected components and add a SEC for each one.\\
Once we add the SEC obtained by the candidate solution, we patch that solution, using the patching shown in section 5.2, and post it as an heuristic solution.\\
At last, we reject the candidate solution, making sure the incumbent is only updated with connected integer solutions.

\subsection{Relaxation callback}
While the candidate relaxation intercepts integer solutions, the relaxation callback intercepts of the relaxation problem.\\
Since these are solutions too, we might try to create SEC out of those too.\\
To create SEC out of fractionary solutions we have to solve a Network Flow problem, for which we used the concorde software, which is currently the best TSP solver commercially available.\\
As for the candidate callback, we might want to post a patched version of the solution CPLEX gave us: to do so we need to create a new type of patching, which can handle fractionary solutions.\\
This new patching will be based on the greedy algorithm, which we have already seen, choosing the edges not only by the cost, but by the product of the cost of the edge and the "weight" given to the edge by $x^*$ ($c_e * (1 - x^*_e)$).\\
Basically, we consider $x^*_e$ as a confidence value of how much that edge is good or bad: if $x^*_e == 1$ then CPLEX is "confident" about that edge, so we want to consider it in our patched solution (the weighted cost will go to 0); otherwise, if $x^*_e == 0$ then CPLEX choose not to include that edge, so we're not giving it a "discount" on the cost.


\subsection{Results analysis}
\FloatBarrier
\begin{figure}[h]
    \centering
    \includegraphics*[width=.6\textwidth]{../plots/perfprof_bnc_times.png}
    \caption*{20 instances, 300 nodes, time limit: 360s}
\end{figure}
\FloatBarrier
Note that:
\begin{enumerate}
    \item[] Branch and Cut: CPLEX + Candidate Callback
    \item[] (warm): Giving CPLEX a warm start (posting an heuristic at start)
    \item[] (rcb): Using the relaxation callback
\end{enumerate}
The candidate callback is necessary to find a feasible solution without using benders loop, so we might consider it as a baseline.\\
As we can see, adding the relaxation callback will give us a speedup up to 200-300\% times with respect to the baseline.\\
Patching and posting the solutions found inside the callbacks will give us another speedup of 200-300\%:
\FloatBarrier
\begin{figure}[h]
    \centering
    \includegraphics*[width=.6\textwidth]{../plots/perfprof_bnc_patch_times.png}
    \caption*{20 instances, 300 nodes, time limit: 360s}
\end{figure}
\FloatBarrier
Note that:
\begin{enumerate}
    \item (ccb-patch): patching and posting in the candidate callback
    \item (rcb-patch): patching and posting in the relaxation callback
    \item (both-patch): patching and posting in both callbacks
\end{enumerate}

As we can see, patching and posting inside the candidate callback alone, gives us the best performances: patching and posting the solutions just in the relaxation callback, still gives us a great improvement, but apparently patching and posting in the candidate callback is enough to lower the upper bound enough to speedup CPLEX, and the time needed to patch inside the relaxation callback is just an overhead.

\newpage

\section{Comparison Benders / Callbacks}
All those improvements lead us to an high performance sofftware to find the optimal solution of our TSP.\\
Here is shown the overall progress with exact methods:
\FloatBarrier
\begin{figure}[h]
    \centering
    \includegraphics*[width=.6\textwidth]{../plots/perfprof_exact_times_result.png}
    \caption*{20 instances, 300 nodes, time limit: 360s}
\end{figure}
\FloatBarrier

Our final software is 8-10 times faster than the benders loop: this is due to the fact that by operating inside CPLEX with the callback, we are making the changes "locally", while with benders loop CPLEX has to recreate its decision tree at each iterations.