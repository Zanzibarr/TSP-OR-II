A metaheuristic approach is a method in which more than one heuristic is used, with the aim to guide the search processs to efficiently explore the search space.

Metaheuristics will unlock a greater search space with respect to heuristic, by allowing "bad moves" to escape a locally optimal solution.

\section{Tabu Search}
The Tabu search algorithm is based on the idea of allowing the 2-opt algorithm to perform swaps that still are the best ones, but not necessarly swaps that improve the cost of the solution.

This means that after finding a local optima, the 2-opt algorithm will stop, while the tabu search algorithm will keep searching, moving away from that locally optimal solution, hoping to find a new locally optimal solution with a lower cost.

Allowing a bad move, means that at the next iteration the new best move will revert it, since that would be the only swap that lowers the cost.

To prevent this, we need to keep track of those bad moves and prevent them from being reverted, marking them as tabu moves, hence the name of the algorithm.

...
\subsection{Storing a Tabu move}

A tabu move is intended as the worsening move that has been done in a previous round, and it basically consists on the 4 edges, or the 2 nodes, that were considered in the swap.

To store the tabu move we have more options:

\begin{enumerate}
    \item Mark as tabu one of the nodes (fix the two edges connected to that node)
    \item Mark as tabu both nodes (fix all four edges in the swap)
    \item Mark as tabu one edge or more edges
\end{enumerate}

Marking one or both nodes as tabu moves would restrict our area of search, since after a few tabu moves, lots of edges cannot be changed, so we opted to mark as a tabu move the two edges $(p_{i},p_{i+1})$ and $(p_{j}, p_{j+1})$.

\subsection{The tabu list}

The tabu list is intended as the list of tabu moves, that 2-opt will need to consult to see wether a move is admitted or not.

Once the tabu list is filled up, the oldest tabu move will be removed to let the new tabu move be saved.

An important factor regarding the tabu list, is its size: a small size means that the algorithm is not free to explore much the search space, while a big size means that the algorithm will worsen too much the solution, risking in not be able to ever find a better solution.

Another way to look at the size of the tabu list is to consider it as its memory: a small tabu list will forget earlier tabu moves, while a big tabu list will have a longer memory.

The size (or memory) of the tabu list will be referred as the tenure of the tabu list.

We built the tabu list as a fixed length array, where we stored each tabu move together with a counter which increases at each new tabu move.

We used the counter to view if a move is still a tabu move or not: by comparing the current counter with the one stored along the move, we can check how many iterations has passed and if more iterations than the tenure has occurred, that moves is no longer a tabu move.

We tried out two ways of checking the tenure:

\begin{enumerate}
    \item Static approach: a move in the list is no longer a tabu move if
    $$\text{counter}-\text{counter(move)} < \text{tenure}$$
    Where $\text{counter(move)}$ is the counter stored along the move in the tabu list.
    \item Dinamic approach: a move in the list is no longer a tabu move if
    $$\text{counter}-\text{counter(move)} < f(\text{tenure}, \text{counter})$$
    Where $f(\text{tenure},\text{counter})\coloneq \text{A}\cdot\sin(\text{counter}\cdot\text{B}) + \text{tenure}$, and $A$, $B$ are parameters given by the user (referred as variable\_tenure and variability\_frequency).
\end{enumerate}

Here are shown two graphs, plotting the iteration counter and the cost of the solution the algorithm finds itself at:

TODO: Plot cost of tabu.

The dinamic approach performs better for a few reasons:

\begin{enumerate}
    \item Lowers the risk of getting stuck: with the dinamic approach if the algorithm get stuck, in a few iteration it will start to forget some moves and escapes from that situation
    \item Allows for a more dinamic exploration of the search space: the dinamic approach allows the algorithm to "forget" something to look for a better solution in the search space, but the remember it later if that lead to nothing.
\end{enumerate}

\subsection{Pseudocode}

\begin{algorithm}
    \caption{tabu algorithm for the TSP}
    \hspace*{\algorithmicindent} \textbf{Input} Starting node ($s\in V$), Set of nodes ($V$)\\
    \hspace*{\algorithmicindent} \textbf{Output} List of $n\coloneq|V|$ nodes forming an Hamiltonian cycle, Cost of the cycle
    \begin{algorithmic}\\
        
        \State $\mbox{cycle}, \mbox{cost} \gets \mbox{greedy}(s, V)$\\

        \While{*Within the time limit*}\\
            \State $(i, j)\gets \mbox{find\_tabu\_swap(cycle)}$
            \State $\mbox{add\_to\_tabu(i, j)}$
            \State $\mbox{cost}\gets\mbox{cost}-(c_{p_i,p_{i+1}}+c_{p_j,p_{j+1}})+(c_{p_i,p_{j}}+c_{p_{i+1},p_{j+1}})$
            \State $\mbox{reverse}(\mbox{cycle}, i+1, j)$\\

        \EndWhile\\\\

        \Return cycle, cost
    \end{algorithmic}
\end{algorithm}

Where the $\mbox{find\_tabu\_swap()}$ method returns the best swap (allowing for bad moves) after checking the tabu list.

\subsection{Results analysis}
TODO: Comparison with 2-opt\\

TODO: Comparison between dinamic / static approach
\section{Variable Neighborhood Search (VNS)}
For the tabu algorithm to work, a list of moves must be stored as tabu moves: how many moves to store? Is it better a static or dinamic tenure? In the dinamic approach, how much should the tenure vary? Those are all hyperparameters that should be set through lots of try and error generating the risk of overfitting.

Another approach to metaheuristics that doesn't require hyperparameters, is the Variable Neighborhood Search (VNS), which has the same base idea of the tabu search, but approaches to it differently.

Once we are in a local minimum, if we make a 2-opt swap (as we do with the tabu algorithm), we must save that move as a tabu move, since the next 2-opt swap will revert it.

The VNS approach is to make a swap that requires more than two edges to be swapped (entering the family of k-opt), in our case a 3-opt swap.

Once a 3-opt swap is performed, it's impossible for a 2-opt swap to reverse that change, since it should change 3 edges and it's allowed to change only 2 of them.

In some scenarios one 3-opt swap is enough to escape the local minimum, but in other it's not and more swaps are needed (an hyperparameter).

To prevent having to set an hyperparameter, we used multithreading to perform dirrerent numbers of 3-opt swaps on a local minimum, then use the 2-opt algorithm to lower the cost, and choose the best among the solutions found.

Another approach that can be explored in the future is using multithreading to keep the $k$ best choices among the solutions found and keep exploring them in parallel (with special attention to keep the list of parallel runs under control, avoiding exponential growth).
\subsection{Results analysis}
TODO: Comparison with 2-opt
\section{Comparison Tabu / VNS}
TODO: Comparison with tabu