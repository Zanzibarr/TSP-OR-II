All the algorithms written in this thesis (to solve the TSP) where written using the C language, both due to its speed and CPLEX support for the language.

Plotting and testing are done with Python3, due to it's extensive plotting libraries and the ease in writing it.

\section{Generating the instances}

The instances used to test the algorithms have been randomly generated.

The problem space is a 2D grid: $[0,10\_000]\times[0,10\_000]\subset\mathbb{R}^2$.

Each point is generated from an i.i.d. uniform distribution of the grid defined earlier.

\section{Installing CPLEX}

To view the exact solution of our problem (optimal solution), we opted for (IBM ILOG) CPLEX as a MIP (Mixed Integer Programming) solver.

To get cplex visit IBM's web page and look for the CPLEX Optimization Studio.

TODO: maybe add something else?


\section{Reading the solution plots}

Each solution found is accompanied by a plot showing (graphically) the solution with some info.

Here's a list of the explanation of the info showed in the plots:

\begin{enumerate}
    \item The name of the algorithm used:
    \begin{enumerate}
        \item[greedy]: Nearest Neighborg greedy algorithm
        \item[g2opt]: applying 2opt to the greedy solution
        \item[tabu]: Tabu algorithm
        \item[vns]: VNS algorithm
        \item[cplex]: CPLEX exact algorithm
    \end{enumerate}
    \item In the same line of the algorithm there might be written some parameters used:
    \begin{enumerate}
        \item[g2opt]: (f) $\rightarrow$ g2opt with first swap policy
        \item[g2opt]: (b) $\rightarrow$ g2opt with best swap policy
        \item[tabu]: int-int-double $\rightarrow$ tabu with fixed\_tenure - variable\_tenure - variability\_frequency parameters
        \item[cplex]: benders loop $\rightarrow$ using benders loop
        \item[cplex]: mipst $\rightarrow$ giving cplex a "warm" start
        \item[cplex]: ccb $\rightarrow$ using the candidate callback
        \item[cplex]: rcb $\rightarrow$ using the relaxation callback
        \item[cplex]: n/g-patch $\rightarrow$ using patching if the solution provided is disconnected
        \item[cplex]: ccb/rcb-patch $\rightarrow$ using patching inside the (respective) callbacks
    \end{enumerate}
    (each parameter will be explained in the respective section).\\
    If the algorithm exceeded the time limit or has been terminated early by the user, an asterisk (*) will be shown at the end of the first line
    \item cost: the cost of the Hamiltonian Cycle found
    \item double/double: time needed to find that solution / total computing time
\end{enumerate}

\section{Performance profiler}

To compare different algorithms we used the performance profiles, a tool provied by our professor that plots how often an algorithm is within a percentage of the cost from the best solution found

TODO: Explain better how to read the plot
